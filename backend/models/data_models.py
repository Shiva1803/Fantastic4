"""
Data models for Conversation Autopilot.

This module defines all data structures used throughout the application,
including StyleProfile, Message, EscalationResult, ConversationSession,
and ConversationSummary.
"""

from dataclasses import dataclass, field, asdict
from typing import List, Optional, Literal, Dict
from datetime import datetime


@dataclass
class StyleProfile:
    """
    Represents a user's texting style profile extracted from training data.
    
    Attributes:
        sentence_length: Classification of typical sentence length
        emoji_frequency: Ratio of messages containing emojis (0-1)
        common_emojis: List of frequently used emojis
        punctuation_style: Description of punctuation usage
        tone: Overall communication tone
        common_phrases: Frequently used expressions
        formality_level: Degree of formality (0=casual, 1=formal)
        analysis_timestamp: When the profile was created
    """
    sentence_length: Literal["short", "medium", "long"]
    emoji_frequency: float
    common_emojis: List[str]
    punctuation_style: str
    tone: Literal["casual", "formal", "mixed"]
    common_phrases: List[str]
    formality_level: float
    analysis_timestamp: str
    
    def __post_init__(self):
        """Validate field values after initialization."""
        if not 0 <= self.emoji_frequency <= 1:
            raise ValueError("emoji_frequency must be between 0 and 1")
        if not 0 <= self.formality_level <= 1:
            raise ValueError("formality_level must be between 0 and 1")
        if self.sentence_length not in ["short", "medium", "long"]:
            raise ValueError("sentence_length must be 'short', 'medium', or 'long'")
        if self.tone not in ["casual", "formal", "mixed"]:
            raise ValueError("tone must be 'casual', 'formal', or 'mixed'")
    
    def to_dict(self) -> dict:
        """Convert StyleProfile to dictionary for JSON serialization (camelCase for frontend)."""
        return {
            'sentenceLength': self.sentence_length,
            'emojiFrequency': self.emoji_frequency,
            'commonEmojis': self.common_emojis,
            'punctuationStyle': self.punctuation_style,
            'tone': self.tone,
            'commonPhrases': self.common_phrases,
            'formalityLevel': self.formality_level,
            'analysisTimestamp': self.analysis_timestamp
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'StyleProfile':
        """Create StyleProfile from dictionary."""
        # Handle both camelCase (from frontend) and snake_case (from backend)
        sentence_length = data.get('sentence_length') or data.get('sentenceLength')
        emoji_frequency = data.get('emoji_frequency') if 'emoji_frequency' in data else data.get('emojiFrequency')
        common_emojis = data.get('common_emojis') or data.get('commonEmojis', [])
        punctuation_style = data.get('punctuation_style') or data.get('punctuationStyle')
        tone = data.get('tone')
        common_phrases = data.get('common_phrases') or data.get('commonPhrases', [])
        formality_level = data.get('formality_level') if 'formality_level' in data else data.get('formalityLevel')
        analysis_timestamp = data.get('analysis_timestamp') or data.get('analysisTimestamp')
        
        return cls(
            sentence_length=sentence_length,
            emoji_frequency=emoji_frequency,
            common_emojis=common_emojis,
            punctuation_style=punctuation_style,
            tone=tone,
            common_phrases=common_phrases,
            formality_level=formality_level,
            analysis_timestamp=analysis_timestamp
        )


@dataclass
class Message:
    """
    Represents a single message in a conversation.
    
    Attributes:
        id: Unique message identifier
        sender: Who sent the message (user, friend, or ai)
        text: Message content
        timestamp: When the message was sent (ISO 8601)
        is_ai_generated: Whether the message was generated by AI
    """
    id: str
    sender: Literal["user", "friend", "ai"]
    text: str
    timestamp: str
    is_ai_generated: bool
    
    def __post_init__(self):
        """Validate field values after initialization."""
        if self.sender not in ["user", "friend", "ai"]:
            raise ValueError("sender must be 'user', 'friend', or 'ai'")
        if not self.text.strip():
            raise ValueError("text cannot be empty")
    
    def to_dict(self) -> dict:
        """Convert Message to dictionary for JSON serialization (camelCase for frontend)."""
        return {
            'id': self.id,
            'sender': self.sender,
            'text': self.text,
            'timestamp': self.timestamp,
            'isAiGenerated': self.is_ai_generated
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'Message':
        """Create Message from dictionary."""
        # Handle both camelCase (from frontend) and snake_case (from backend)
        is_ai_generated = data.get('is_ai_generated') or data.get('isAiGenerated', False)
        
        return cls(
            id=data['id'],
            sender=data['sender'],
            text=data['text'],
            timestamp=data['timestamp'],
            is_ai_generated=is_ai_generated
        )


@dataclass
class EscalationResult:
    """
    Represents the result of escalation detection analysis.
    
    Attributes:
        detected: Whether escalation was detected
        confidence_score: AI's confidence in handling the message (0-100)
        reason: Explanation for escalation (if detected)
        category: Type of escalation trigger
    """
    detected: bool
    confidence_score: float
    reason: Optional[str] = None
    category: Optional[Literal[
        "serious_question",
        "emotional_distress",
        "unfamiliar_topic",
        "scheduling",
        "sensitive_info"
    ]] = None
    
    def __post_init__(self):
        """Validate field values after initialization."""
        if not 0 <= self.confidence_score <= 100:
            raise ValueError("confidence_score must be between 0 and 100")
        if self.detected and not self.reason:
            raise ValueError("reason is required when detected is True")
    
    def to_dict(self) -> dict:
        """Convert EscalationResult to dictionary for JSON serialization (camelCase for frontend)."""
        return {
            'detected': self.detected,
            'confidenceScore': self.confidence_score,
            'reason': self.reason,
            'category': self.category
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'EscalationResult':
        """Create EscalationResult from dictionary."""
        # Handle both camelCase (from frontend) and snake_case (from backend)
        confidence_score = data.get('confidence_score') if 'confidence_score' in data else data.get('confidenceScore')
        
        return cls(
            detected=data['detected'],
            confidence_score=confidence_score,
            reason=data.get('reason'),
            category=data.get('category')
        )


@dataclass
class ConversationSession:
    """
    Represents an active conversation session.
    
    Attributes:
        session_id: Unique session identifier
        messages: List of messages in the conversation
        style_profile: User's texting style profile
        start_time: When the session started (ISO 8601)
        end_time: When the session ended (ISO 8601), if applicable
        escalation_count: Number of escalations detected in session
    """
    session_id: str
    messages: List[Message]
    style_profile: StyleProfile
    start_time: str
    end_time: Optional[str] = None
    escalation_count: int = 0
    
    def __post_init__(self):
        """Validate field values after initialization."""
        if self.escalation_count < 0:
            raise ValueError("escalation_count cannot be negative")
    
    def to_dict(self) -> dict:
        """Convert ConversationSession to dictionary for JSON serialization (camelCase for frontend)."""
        return {
            'sessionId': self.session_id,
            'messages': [msg.to_dict() for msg in self.messages],
            'styleProfile': self.style_profile.to_dict(),
            'startTime': self.start_time,
            'endTime': self.end_time,
            'escalationCount': self.escalation_count
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'ConversationSession':
        """Create ConversationSession from dictionary."""
        # Handle both camelCase (from frontend) and snake_case (from backend)
        session_id = data.get('session_id') or data.get('sessionId')
        style_profile_dict = data.get('style_profile') or data.get('styleProfile')
        start_time = data.get('start_time') or data.get('startTime')
        end_time = data.get('end_time') or data.get('endTime')
        escalation_count = data.get('escalation_count') if 'escalation_count' in data else data.get('escalationCount', 0)
        
        return cls(
            session_id=session_id,
            messages=[Message.from_dict(msg) for msg in data['messages']],
            style_profile=StyleProfile.from_dict(style_profile_dict),
            start_time=start_time,
            end_time=end_time,
            escalation_count=escalation_count
        )


@dataclass
class ConversationSummary:
    """
    Represents a summary of a completed conversation session.
    
    Attributes:
        session_id: Unique session identifier
        transcript: Full list of messages
        commitments: Plans, promises, or information shared
        action_items: Tasks or follow-ups identified
        key_topics: Main discussion themes
        ai_message_count: Number of AI-generated messages
        human_message_count: Number of human-written messages
        escalation_count: Number of escalations during session
        duration: Session duration in seconds
    """
    session_id: str
    transcript: List[Message]
    commitments: List[str]
    action_items: List[str]
    key_topics: List[str]
    ai_message_count: int
    human_message_count: int
    escalation_count: int = 0
    duration: int = 0
    
    def __post_init__(self):
        """Validate field values after initialization."""
        if self.ai_message_count < 0:
            raise ValueError("ai_message_count cannot be negative")
        if self.human_message_count < 0:
            raise ValueError("human_message_count cannot be negative")
        if self.escalation_count < 0:
            raise ValueError("escalation_count cannot be negative")
        if self.duration < 0:
            raise ValueError("duration cannot be negative")
    
    def to_dict(self) -> dict:
        """Convert ConversationSummary to dictionary for JSON serialization (camelCase for frontend)."""
        return {
            'sessionId': self.session_id,
            'transcript': [msg.to_dict() for msg in self.transcript],
            'commitments': self.commitments,
            'actionItems': self.action_items,
            'keyTopics': self.key_topics,
            'aiMessageCount': self.ai_message_count,
            'humanMessageCount': self.human_message_count,
            'escalationCount': self.escalation_count,
            'duration': self.duration
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'ConversationSummary':
        """Create ConversationSummary from dictionary."""
        # Handle both camelCase (from frontend) and snake_case (from backend)
        session_id = data.get('session_id') or data.get('sessionId')
        action_items = data.get('action_items') or data.get('actionItems', [])
        key_topics = data.get('key_topics') or data.get('keyTopics', [])
        ai_message_count = data.get('ai_message_count') if 'ai_message_count' in data else data.get('aiMessageCount')
        human_message_count = data.get('human_message_count') if 'human_message_count' in data else data.get('humanMessageCount')
        escalation_count = data.get('escalation_count') if 'escalation_count' in data else data.get('escalationCount', 0)
        duration = data.get('duration', 0)
        
        # Parse transcript
        transcript_data = data.get('transcript', [])
        transcript = [Message.from_dict(msg) if isinstance(msg, dict) else msg for msg in transcript_data]
        
        return cls(
            session_id=session_id,
            transcript=transcript,
            commitments=data.get('commitments', []),
            action_items=action_items,
            key_topics=key_topics,
            ai_message_count=ai_message_count,
            human_message_count=human_message_count,
            escalation_count=escalation_count,
            duration=duration
        )


@dataclass
class Space:
    """
    Represents a conversation space for organizing content.
    
    Attributes:
        id: Unique space identifier
        user_id: Owner of the space
        name: Name of the space
        description: Optional description
        created_at: Creation timestamp (ISO 8601)
        updated_at: Last update timestamp (ISO 8601)
        item_count: Number of items in the space
    """
    id: str
    user_id: str
    name: str
    description: Optional[str]
    created_at: str
    updated_at: str
    item_count: int = 0
    
    def __post_init__(self):
        """Validate field values after initialization."""
        if not self.name or not self.name.strip():
            raise ValueError("name is required")
        if len(self.name) > 50:
            raise ValueError("name must be 50 characters or less")
        if self.description and len(self.description) > 500:
            raise ValueError("description must be 500 characters or less")
        if self.item_count < 0:
            raise ValueError("item_count cannot be negative")
            
    def to_dict(self) -> dict:
        """Convert Space to dictionary for JSON serialization (camelCase for frontend)."""
        return {
            'id': self.id,
            'userId': self.user_id,
            'name': self.name,
            'description': self.description,
            'createdAt': self.created_at,
            'updatedAt': self.updated_at,
            'itemCount': self.item_count
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'Space':
        """Create Space from dictionary."""
        # Handle both camelCase (from frontend) and snake_case (from backend)
        user_id = data.get('user_id') or data.get('userId')
        created_at = data.get('created_at') or data.get('createdAt')
        updated_at = data.get('updated_at') or data.get('updatedAt')
        item_count = data.get('item_count') if 'item_count' in data else data.get('itemCount', 0)
        
        return cls(
            id=data['id'],
            user_id=user_id,
            name=data['name'],
            description=data.get('description'),
            created_at=created_at,
            updated_at=updated_at,
            item_count=item_count
        )


@dataclass
class SpaceItem:
    """
    Represents an item saved within a space (message, file, etc.).
    
    Attributes:
        id: Unique item identifier
        space_id: Space this item belongs to
        type: Type of item (message, file)
        content: Text content or file path/url
        notes: User notes about the item
        metadata: JSON metadata (file size, original name, etc.)
        created_at: Creation timestamp (ISO 8601)
    """
    id: str
    space_id: str
    type: Literal["message", "file"]
    content: str
    notes: Optional[str]
    metadata: Dict
    created_at: str
    
    def __post_init__(self):
        """Validate field values after initialization."""
        if self.type not in ["message", "file"]:
            raise ValueError("type must be 'message' or 'file'")
        if not self.content:
            raise ValueError("content is required")
            
    def to_dict(self) -> dict:
        """Convert SpaceItem to dictionary for JSON serialization (camelCase for frontend)."""
        return {
            'id': self.id,
            'spaceId': self.space_id,
            'type': self.type,
            'content': self.content,
            'notes': self.notes,
            'metadata': self.metadata,
            'createdAt': self.created_at
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'SpaceItem':
        """Create SpaceItem from dictionary."""
        # Handle both camelCase (from frontend) and snake_case (from backend)
        space_id = data.get('space_id') or data.get('spaceId')
        created_at = data.get('created_at') or data.get('createdAt')
        
        return cls(
            id=data['id'],
            space_id=space_id,
            type=data['type'],
            content=data['content'],
            notes=data.get('notes'),
            metadata=data.get('metadata', {}),
            created_at=created_at
        )


@dataclass
class Query:
    """
    Represents a RAG query and its answer.
    
    Attributes:
        id: Unique query identifier
        space_id: Space this query was asked in
        question: User's question
        answer: Generated answer
        sources: List of source references with scores
        created_at: Creation timestamp (ISO 8601)
    """
    id: str
    space_id: str
    question: str
    answer: str
    sources: List[Dict]
    created_at: str
    
    def to_dict(self) -> dict:
        """Convert Query to dictionary for JSON serialization."""
        return {
            'id': self.id,
            'spaceId': self.space_id,
            'question': self.question,
            'answer': self.answer,
            'sources': self.sources,
            'createdAt': self.created_at
        }

